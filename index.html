<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Table Compare Tool</title>
  <style>

    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      margin: 20px;
      color: #333;
      background-color: #d3f9d8;
    }

    h1, h3 {
      font-weight: 550;
    }

    h1 {
      font-size: 1.8em;
      color: #2f5f3a; /* dark green */
      margin-bottom: 10px;
    }

    .section {
      margin-bottom: 20px;
    }

    textarea {
      width: 100%;
      height: 150px;
      padding: 10px;
      font-family: monospace;
      border: 1px solid #ccc;
      border-radius: 4px;
      resize: vertical;
      box-sizing: border-box;
    }

    .input-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .manipulation-inputs {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .manipulation-inputs input {
      padding: 5px;
      width: 80px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    .manipulation-inputs input.invalid {
      border-color: red;
    }

    button {
      margin-right: 10px;
      padding: 8px 16px;
      font-weight: bold;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    button:hover {
      background-color: #ddd;
    }

    button.compare {
      background-color: #4CAF50; /* Green */
      color: white;
    }

    button.compare:hover {
      background-color: #45a049;
    }

    .table-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-top: 20px;
    }

    table {
      border-collapse: collapse;
      min-width: 300px;
    }

    .table-title {
      color: gray;
      font-size: 0.9rem;
      font-weight: normal;
      font-style: italic;
      margin-bottom: 5px;
    }

    th, td {
      border: 1px solid #aaa;
      padding: 6px 10px;
      text-align: center;
    }

    .different {
      background-color: #f77;
    }

    h3 {
      margin: 10px 0 5px;
    }

    label {
      padding-top: 6px;
      padding-bottom: 6px;
    }
    
  </style>
</head>
<body>

  <h1>Table Compare Tool - Thu Huong KCS</h1>

  <div class="section input-grid">
    <div>
      <label><strong>Paste Table 1 (Excel):</strong></label>
      <textarea id="input1" placeholder="Paste Table 1 from Excel" oninput="updateManipulationInputs()"></textarea>
    </div>
    <div>
      <label><strong>Paste Table 2 (Word):</strong></label>
      <textarea id="input2" placeholder="Paste Table 2 from Word"></textarea>
    </div>
  </div>

  <div class="section">
    <strong>LSD Values (Per Column):</strong>
    <div class="manipulation-inputs" id="manipulationInputs"></div>
  </div>

  <div class="section">
    <button class="compare" onclick="compareTables()">Compare</button>
    <button onclick="clearAll()">Clear</button>
  </div>

  <div class="table-container">
    <div id="table1"></div>
    <div id="table2"></div>
  </div>

  <!-- The script section remains unchanged (reuse your current script) -->
</body>
</html>


  <script>
    
    function processEach(n, e) {
      const map = group([...n], parseFloat(e));
      const processedList = new Array(n.length);

      for (let m = 0; m < processedList.length; m++) {
        processedList[m] = `${n[m]} ${map.get(parseFloat(n[m]))}`;
      }

      return processedList;
    }

    function group(n, e) {
      n = n.map(x => parseFloat(x));
      n.sort((a, b) => a - b);
      reverse(n);

      const result = new Array(n.length).fill("");

      const groups = ["a", "b", "c", "d"];
      let groupCount = 0;
      let groupName = groups[groupCount];
      let i = 0;

      while (i < n.length) {
        let limit = n[i] - e;
        while (i < n.length && n[i] >= limit) {
          result[i] += groupName;
          i++;
        }
        if (i === n.length) break;

        groupName = groups[++groupCount % groups.length];
        let begin = n[i] + e;
        let a = i - 1;
        while (a >= 0 && n[a] <= begin) {
          a--;
        }
        i = a + 1;
      }

      const resultGroup = new Map();
      for (let k = 0; k < n.length; k++) {
        resultGroup.set(n[k], result[k]);
      }

      return resultGroup;
    }

    function reverse(arr) {
      let n = arr.length;
      for (let i = 0; i < Math.floor(n / 2); i++) {
        let temp = arr[i];
        arr[i] = arr[n - i - 1];
        arr[n - i - 1] = temp;
      }
    }

    function parseCell(cell) {
      const cleaned = cell.trim().replace(',', '.'); // Normalize comma to dot
      console.log(cleaned)
      const match = cleaned.match(/^(-?\d+(?:\.\d+)?)(\s*\D.*)?$/);
      console.log(match)
      if (match) {
        return {
          num: parseFloat(match[1]),
          str: (match[2] || '').trim()
        };
      } else {
        return { num: null, str: cleaned };
      }
    }

    function parseExcelText(text) {
      return text.trim().split('\n').map(row => row.split('\t'));
    }

    function updateManipulationInputs() {
      const data = parseExcelText(document.getElementById('input1').value);
      const container = document.getElementById('manipulationInputs');
      container.innerHTML = '';

      if (data.length === 0 || data[0].length === 0) return;

      const maxCols = Math.max(...data.map(row => row.length));
      // container.innerHTML = '<b>LSD:</b><br>';

      for (let i = 0; i < maxCols; i++) {
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = `Col ${i + 1}`;
        input.dataset.col = i;
        container.appendChild(input);
      }
    }

    function getManipulationValues() {
      const inputs = document.querySelectorAll('#manipulationInputs input');
      const values = [];

      for (const input of inputs) {
        const raw = input.value.trim().replace(',', '.');
        if (raw === '' || isNaN(parseFloat(raw))) {
          alert("Please fill in all LSD values!");
          input.focus();  // focus on the first invalid input
          return null;
        }
        values.push(parseFloat(raw));
      }

      return values;
    }

    function transpose(matrix) {
      const rows = matrix.length;
      const cols = Math.max(...matrix.map(row => row.length));
      const transposed = Array.from({ length: cols }, () => Array(rows).fill(""));
      for (let i = 0; i < rows; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
          transposed[j][i] = matrix[i][j];
        }
      }
      return transposed;
    }

    function validateExcelData(data) {
      for (let row = 0; row < data.length; row++) {
        for (let col = 0; col < data[row].length; col++) {
          const cell = data[row][col].trim();
          if (cell === '') {
            alert(`Empty cell found at row ${row + 1}, column ${col + 1}. Please fill all cells.`);
            return false;
          }
        }
      }
      return true;
    }

    function compareTables() {
      const raw1 = parseExcelText(document.getElementById('input1').value);
      if (!validateExcelData(raw1)) return;
      const raw2 = parseExcelText(document.getElementById('input2').value);
      const values = getManipulationValues();
      if (!values) return;

      const transposed = transpose(raw1);
      const cleanedCols = transposed.map(col => col.map(cell => parseCell(cell).num));
      const manipulatedCols = cleanedCols.map((col, i) => processEach(col, values[i] ?? '0'));
      const manipulatedRows = transpose(manipulatedCols);

      const maxRows = Math.max(manipulatedRows.length, raw2.length);
      const maxCols = Math.max(...[...manipulatedRows, ...raw2].map(row => row.length));
      const diffs = Array.from({ length: maxRows }, () => Array(maxCols).fill(false));

      for (let i = 0; i < maxRows; i++) {
        for (let j = 0; j < maxCols; j++) {
          const val1 = manipulatedRows[i]?.[j] ?? '';
          const val2 = raw2[i]?.[j] ?? '';
          const p1 = parseCell(val1);
          const p2 = parseCell(val2);
          if (p1.num !== null && p2.num !== null) {
            if (p1.num !== p2.num || p1.str !== p2.str) {
              diffs[i][j] = true;
            }
          } else {
            if (val1.trim() !== val2.trim()) {
              diffs[i][j] = true;
            }
          }
        }
      }

      renderTable(document.getElementById('table1'), manipulatedRows, diffs, "Excel");
      renderTable(document.getElementById('table2'), raw2, diffs, "Word");
    }

    function renderTable(container, data, diffs, title) {
      const wrapper = document.createElement('div');

      const heading = document.createElement('h3');
      heading.textContent = title;
      heading.className = 'table-title';
      wrapper.appendChild(heading);

      const table = document.createElement('table');
      data.forEach((row, i) => {
        const tr = document.createElement('tr');
        row.forEach((cell, j) => {
          const td = document.createElement('td');
          td.textContent = cell;
          if (diffs && diffs[i] && diffs[i][j]) {
            td.classList.add('different');
          }
          tr.appendChild(td);
        });
        table.appendChild(tr);
      });

      wrapper.appendChild(table);
      container.innerHTML = '';
      container.appendChild(wrapper);
    }

    function clearAll() {
      document.getElementById('input1').value = '';
      document.getElementById('input2').value = '';
      document.getElementById('manipulationInputs').innerHTML = '';
      document.getElementById('table1').innerHTML = '';
      document.getElementById('table2').innerHTML = '';
    }
  </script>

</body>
</html>
